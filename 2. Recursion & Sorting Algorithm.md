# 2. Recursion & Sorting Algorithm

## 1). Selection Sort

* #### Definition

  The selection sort algorithm sorts an array by repeatedly finding the minimum element(considering asending order) from unsorting part and putting it at the beginning.The algorithm maintains two subarrays in a given array.

  1). The subarray which is already sorted. 

  2). Remaining subarray which is unsorted.

  In every iteration of selection sort, the minimum element (considering ascending order) from the unsorted subarray is picked and moved to the sorted subarray. 

* #### Code Approach

  ```python
  def selection_sort(target_list):
    for i in range(len(target_list)):
      min_index = i
      for j in range(len(target_list)+1):
        if target_list[j] < target_list[i]:
          min_index = j
      target_list[i],target_list[min_index] = target_list[min_index],target_list[i]
    return target_list
  ```


* #### Time Complexity: O(n^2)

## 2). Merge Sort

* #### Definititon

  Merge sort divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves. **The merge() function** is used for merging two halves. The merge(arr, l, m, r) is a key process that assumes that arr[l..m] and arr[m+1..r] are sorted and merges the two sorted sub-arrays into one. See the following C implementation for details.

* ![Screen Shot 2021-09-27 at 11.46.14 PM](/Users/xinfengliu/Desktop/Screen Shot 2021-09-27 at 11.46.14 PM.png)

* #### Code Approach

  ```python
  def MergeSort(array):
    if len(array) > 1:
      mid = len(array)//2
      L = array[:mid]
      R = array[mid:]
    
      #mergesort left part
      MergeSort(L)
      #mergesort right part
      MergeSort(R)
    
      #i,j = the smalleast unpicked index of L and R; k=position needed to be fitted in sorted list
      i = j = k = 0
      while i<len(L) and j<len(R):
        if L[i] < R[j]:
          array[k] = L[i]
          i += 1
        else:
          array[k] = R[j]
          j += 1
          k += 1
    
      # if one part of array exaust first(i=len(L)orj=len(R)), need to pick element for the other half
      while i<len(L):
        array[k] = L[i]
        i += 1
        k += 1
      while j < len(R):
        array[k] = R[j]
        j += 1
        k += 1
      return array
  ```


## 3). Quick Sort

* #### Definition

  Like merge sort, quick sort is also a divide and conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot. There are different version of picking a pivot:

  1). always pick the first element

  2). always pick the last element

  3). pick a random element

  4). pick median as pivot

* #### Code Approach

  ```python
  def QuickSort(input_list):
    if len(input_list) < 2:
      return input_list
    else:
      pivot = input_list[0]
      low = [i for i in input_list[1:] if i < pivot]
      high = [i for i in input_lits[1:] if i > pivot]
      return QuickSort(low) + pivot + QuickSort(high)
  ```

## 4). Bubble Sort

* #### Definition

  A comparison-based algorithm in which each pair of adjacent elements is compared and the element are sawpped if they are not in order

* #### Code Approach

  ```python
  def BubbleSort(input_list):
    for i in range(len(input_list)-1):
      for j in range(i+1, len(input_list)):
        if input_list[i] > input_list[j]:
          temp = input_list[i]
          input_list[i] = input_list[j]
          input_list[j] = temp
  ```

## 5). Heap Sort

* #### Definition

  A comparison based sorting algorithm based on binary heap structure. It is similar to selection sort where we first find the max element and palce the max at the end. Repeating the process for remaining element.

* #### Code Approach

  ```python
  def heapify(arr, n, i):
    """
    arr: input array
    n: length of arr
    i: current position index
    """
     # Find largest among root and children
     largest = i
     l = 2 * i + 1
     r = 2 * i + 2
     if l < n and arr[i] < arr[l]:
        largest = l
     if r < n and arr[largest] < arr[r]:
        largest = r
     # If root is not largest, swap with largest and continue heapifying
     if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
  
  def heapSort(arr):
     n = len(arr)
     # Build max heap
     # iternal nodes
     for i in range(n//2-1, -1, -1):
        heapify(arr, n, i)
     # leaf nodes
     for i in range(n-1, 0, -1):
        # Swap
        arr[i], arr[0] = arr[0], arr[i]
        # Heapify root element
        heapify(arr, i, 0)
  ```

  

