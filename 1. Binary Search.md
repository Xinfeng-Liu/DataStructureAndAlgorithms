# 1. Binary Search

1. Definition

   Search a **sorted** array by repeatedly divisding the search interval in half. Begin with an interval covering the whole array. If the values of search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half. Repeatedly check until the value is found or the inetrval is empty.

2. Example

   ![Screen Shot 2021-09-22 at 7.22.19 PM](/Users/xinfengliu/Desktop/Screen Shot 2021-09-22 at 7.22.19 PM.png)

   3. Code Approach
      1. Recursive

         ```python
         def binary_search(sorted_array,low_index,high_index, target):
           ite = 0
           if low_index <= high_index:
             middle_index = (high_index + low_index)/2
             if sorted_array[middle_index] == target:
               ite += 1
               return (middle_index,ite)
             elif sorted_array[middle_index] < target: 
               ite += 1
               return (binary_search(sorted_array,middle_index+1,high_index,target), ite)
             else:
               ite += 1
               return (binary_search(sorted_array,low_index,middle_index-1,target), ite)
           else:
             print("Element not presented in the array")
         ```

      2. Iterative

         ```python
         import math
         
         def binary_search(sorted_array,target):
           ite = 0
           high_index = len(sorted_array)-1
           low_index = 0
           
           while low_index <= high_index:
             middle_index = math.floor((high_index+low_index)/2)
             if sorted_array[middle_index] == target:
               ite += 1
               return (middle_index, ite)
             elif sorted_array[middle_index] < target:
               low_index = middle_index + 1
               ite += 1
             else:
               high_index = middle_index - 1
               ite += 1
           print("Element not presented in the array")
         ```

   4. Time Complexity = O(log2 n)

   5. LeetCode

      1. (35 Easy)Search Insert Position. Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order

         ```python
         def searchInsert(nums, target):
             high_index = len(nums)-1
             low_index = 0
         
             while low_index <= high_index:
                 middle_index = (high_index-low_index)//2
                 if nums[middle_index] == target:
                     return (middle_index)
                 elif nums[middle_index] < target:
                     low_index = middle_index + 1
                 else:
                     high_index = middle_index - 1
             return low_index
         ```

      2. (74 Medium BS in 2D Array) Write an efficient algorithm that searches for a value in an `m x n` matrix. This matrix has the following properties:

         - Integers in each row are sorted from left to right.

         - The first integer of each row is greater than the last integer of the previous row.

           |  1   |  3   |  5   |  7   |
           | :--: | :--: | :--: | :--: |
           |  8   |  10  |  11  |  13  |
           |  15  |  16  |  18  |  19  |

         ```python
         def binary_search_2d(matrix,traget):
           row = len(matrix)
           col = len(matrix[0])
           low_index = 0
           high_index = row * col - 1
           
           if row = 0:
             print("Element not in the 2d array")
           
           while low_index <= high_index:
             mid_index = (low_index + high_index)//2
             pivot = matrix[mid_index//col][mid_index%col]
             if pivot == traget:
               print("The target's position is [{ },{ }]".format(mid_index//col,mid_index%col))
             elif pivot < traget:
               low_index = mid_index + 1
             else:
               high_index = mid_index - 1
           print("element not in the 2d list") 
             
         ```

         









